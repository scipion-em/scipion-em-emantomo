# **************************************************************************
# *
# * Authors:    Scipion Team (scipion@cnb.csic.es)
# *
# * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 3 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307  USA
# *
# *  All comments concerning this program package may be sent to the
# *  e-mail address 'scipion@cnb.csic.es'
# *
# **************************************************************************
from os.path import exists
import numpy as np
from pyworkflow.utils import magentaStr
from .test_eman_base import TestEmantomoBase
from ..constants import EMAN_COVERAGE, EMAN_SCORE
from tomo.constants import TR_EMAN
from ..protocols import EmanProtTomoInitialModel
from ..protocols.protocol_average_subtomos import OutputsAverageSubtomos, EmanProtSubTomoAverage
from ..protocols.protocol_pca_classify_subtomos import pcaOutputObjects, EmanProtPcaTomoClassifySubtomos
from ..protocols.protocol_tomo_extraction_from_tomo import SAME_AS_PICKING
from ..protocols.protocol_tomo_initialmodel import OutputsInitModel
from ..protocols.protocol_tomo_subtomogram_refinement import EmanTomoRefinementOutputs, EmanProtTomoRefinement


class TestEmanTomoAverageSubtomograms(TestEmantomoBase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            super().runPreviousProtocols()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    def test_averageSubtomograms(self):
        avgSubtomo = super().runAverageSubtomograms()
        super().checkAverage(avgSubtomo, boxSize=super().binnedBoxSize)


class TestEmanTomoInitialModel(TestEmantomoBase):

    avgSubtomo = None

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            super().runPreviousProtocols()
            cls.avgSubtomo = super().runAverageSubtomograms()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    @classmethod
    def runGenInitialModel(cls):
        print(magentaStr("\n==> Generating the initial model:"))
        protInitModel = cls.newProtocol(EmanProtTomoInitialModel,
                                        particles=cls.subtomosExtracted,
                                        reference=cls.avgSubtomo,
                                        numberOfIterations=2)
        cls.launchProtocol(protInitModel)
        initModel = getattr(protInitModel, OutputsInitModel.average.name, None)
        cls.assertIsNotNone(initModel, "There was a problem calculating the initial model")
        return initModel

    def test_genInitialModel(self):
        initModel = self.runGenInitialModel()
        super().checkAverage(initModel, boxSize=super().binnedBoxSize, halvesExpected=False)


class TestEmanTomoPcaClassification(TestEmantomoBase):

    pcaNumClasses = 2
    mask = None

    @classmethod
    def setUpClass(cls):
        # JORGE
        import os
        fname = "/home/jjimenez/Desktop/test_JJ.txt"
        if os.path.exists(fname):
            os.remove(fname)
        fjj = open(fname, "a+")
        fjj.write('JORGE--------->onDebugMode PID {}'.format(os.getpid()))
        fjj.close()
        print('JORGE--------->onDebugMode PID {}'.format(os.getpid()))
        import time
        time.sleep(10)
        # JORGE_END
        super().setUpClass()
        cls.pcaResults = cls.genTestPcaClassifResults()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            cls.mask = super().runCreate3dMask()  # Generate a mask
            super().runPreviousProtocols()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    @staticmethod
    def genTestPcaClassifResults():
        # keys --> classId, values --> subtomogram indices in the stack generated by eman
        # (the same as the objId of the particles)
        return {1: [0, 1, 10, 11, 15, 18, 2, 22, 27, 28, 3, 4, 5, 6, 7, 8, 9],
                2: [12, 13, 14, 16, 17, 19, 20, 21, 23, 24, 25, 26, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]}

    @classmethod
    def runPcaClassification(cls, mask=None):
        print(magentaStr("\n==> Running a PCA classification of the subtomograms:"))
        argDict = {
            'inSubtomos': cls.subtomosExtracted,
            'nClass': cls.pcaNumClasses
        }
        objLabel = 'PCA classif'
        if mask:
            argDict['mask'] = mask
            objLabel += ' with mask'

        protPcaClassif = cls.newProtocol(EmanProtPcaTomoClassifySubtomos, **argDict)
        protPcaClassif.setObjLabel(objLabel)
        cls.launchProtocol(protPcaClassif)
        return protPcaClassif

    def test_pcaClassifWithoutMask(self):
        pcaProt = self.runPcaClassification()
        self.checkPcaResults(pcaProt)

    def test_pcaClassifWithMask(self):
        pcaProt = self.runPcaClassification(mask=self.mask)
        self.checkPcaResults(pcaProt)

    def checkPcaResults(self, protPca):
        outSubtomos = getattr(protPca, pcaOutputObjects.subtomograms.name, None)
        outClasses = getattr(protPca, pcaOutputObjects.classes.name, None)

        # Check classes
        self.assertEqual(outClasses.getSize(), self.pcaNumClasses)
        a = []
        for item in outClasses.iterClassItems():
            a.append(item.getClassId())

        z = 1


class TestEmanTomoSubtomogramRefinement(TestEmantomoBase):

    mask = None
    avgSubtomo = None

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            cls.mask = super().runCreate3dMask()  # Generate a mask
            super().runPreviousProtocols()
            cls.avgSubtomo = super().runAverageSubtomograms()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    @classmethod
    def runSubtomogramRefinement(cls, inputRef, mask=None):
        print(magentaStr("\n==> Refining the subtomograms:"))
        inputDict = {'inputSetOfSubTomogram': cls.subtomosExtracted,
                     'inputRef': inputRef,
                     'pkeep': 1,
                     'niter': 2,
                     'numberOfThreads': 10}

        objLabel = 'Subtomo refinement'
        if mask:
            inputDict['maskFile'] = mask
            objLabel += ' with mask'

        protTomoRefinement = cls.newProtocol(EmanProtTomoRefinement, **inputDict)
        protTomoRefinement.setObjLabel(objLabel)
        cls.launchProtocol(protTomoRefinement)
        return protTomoRefinement

    def test_subtomoRefinement(self):
        protSubtomoRefinement = self.runSubtomogramRefinement(self.avgSubtomo)
        self.checkRefinementResults(protSubtomoRefinement)

    def test_subTomoRefinementWithMask(self):
        protSubtomoRefinement = self.runSubtomogramRefinement(self.avgSubtomo, mask=self.mask)
        self.checkRefinementResults(protSubtomoRefinement)

    def checkRefinementResults(self, protRefineSubtomos):
        refinedSubtomos = getattr(protRefineSubtomos, EmanTomoRefinementOutputs.subtomograms.name, None)
        avgSubtomo = getattr(protRefineSubtomos, EmanTomoRefinementOutputs.subtomogramAverage.name, None)
        testDims = (super().binnedBoxSize, super().binnedBoxSize, super().binnedBoxSize)

        # Generation checking
        self.assertIsNotNone(refinedSubtomos)
        self.assertIsNotNone(avgSubtomo)

        # Avg checking
        self.checkAverage(avgSubtomo, boxSize=super().binnedBoxSize)

        # Subtomos checking
        self.assertEqual(refinedSubtomos.getDimensions(), testDims)
        self.assertSetSize(refinedSubtomos, self.nParticles, msg='Expected size of the generated subtomograms is '
                                                                 'different than expected: %i != %i' %
                                                                 (refinedSubtomos.getSize(), self.nParticles))
        self.assertEqual(refinedSubtomos.getCoordinates3D().getSize(), self.nParticles)
        for subTomogram in refinedSubtomos:
            self.assertEqual(subTomogram.getSamplingRate(), super().binnedSRate)
            self.assertTrue(hasattr(subTomogram, EMAN_COVERAGE))
            self.assertTrue(hasattr(subTomogram, EMAN_SCORE))
            matrix = subTomogram.getTransform(convention=TR_EMAN).getMatrix()
            self.assertEqual(matrix.shape, (4, 4))
            self.assertFalse(np.array_equal(matrix, np.eye(4)))  # Then it contains the angles and shitfs

        # FSCs checking
        fscs = getattr(protRefineSubtomos, EmanTomoRefinementOutputs.FSCs.name)
        self.assertSetSize(fscs, 3, msg="FSCs not registered properly")




