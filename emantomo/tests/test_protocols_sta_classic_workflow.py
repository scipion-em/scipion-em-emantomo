# **************************************************************************
# *
# * Authors:    Scipion Team (scipion@cnb.csic.es)
# *
# * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 3 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307  USA
# *
# *  All comments concerning this program package may be sent to the
# *  e-mail address 'scipion@cnb.csic.es'
# *
# **************************************************************************
from os.path import exists

import numpy as np
from pyworkflow.utils import magentaStr
from .test_eman_sta_classic_base import TestEmantomoStaClassicBase
from ..constants import EMAN_COVERAGE, EMAN_SCORE, SPTCLS_00_DIR
from tomo.constants import TR_EMAN
from ..protocols import EmanProtTomoInitialModel
from ..protocols.protocol_pca_kmeans_classify_subtomos import pcaOutputObjects, EmanProtPcaKMeansClassifySubtomos
from ..protocols.protocol_tomo_initialmodel import OutputsInitModel
from ..protocols.protocol_tomo_subtomogram_refinement import EmanTomoRefinementOutputs, EmanProtTomoRefinement


class TestEmanTomoAverageSubtomogramsStaClassic(TestEmantomoStaClassicBase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            super().runPreviousProtocols()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    def test_averageSubtomograms(self):
        avgSubtomo = super().runAverageSubtomograms()
        super().checkAverage(avgSubtomo, boxSize=super().binnedBoxSize)


class TestEmanTomoInitialModelStaClassic(TestEmantomoStaClassicBase):

    avgSubtomo = None

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            super().runPreviousProtocols()
            cls.avgSubtomo = super().runAverageSubtomograms()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    @classmethod
    def runGenInitialModel(cls):
        print(magentaStr("\n==> Generating the initial model:"))
        protInitModel = cls.newProtocol(EmanProtTomoInitialModel,
                                        particles=cls.subtomosExtracted,
                                        reference=cls.avgSubtomo,
                                        numberOfIterations=2)
        cls.launchProtocol(protInitModel)
        initModel = getattr(protInitModel, OutputsInitModel.average.name, None)
        cls.assertIsNotNone(initModel, "There was a problem calculating the initial model")
        return initModel

    def test_genInitialModel(self):
        initModel = self.runGenInitialModel()
        super().checkAverage(initModel, boxSize=super().binnedBoxSize, halvesExpected=False)


class TestEmanTomoPcaClassificationStaClassic(TestEmantomoStaClassicBase):

    pcaNumClasses = 2
    mask = None

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.pcaResults = cls.genTestPcaClassifResults()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            cls.mask = super().runCreate3dMask()  # Generate a mask
            super().runPreviousProtocols()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    @staticmethod
    def genTestPcaClassifResults():
        # keys --> classId, values --> subtomogram indices in the stack generated by eman
        # (the same as the objId of the particles)
        return {1: [0, 1, 10, 11, 15, 18, 2, 22, 27, 28, 3, 4, 5, 6, 7, 8, 9],
                2: [12, 13, 14, 16, 17, 19, 20, 21, 23, 24, 25, 26, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]}

    @classmethod
    def runPcaClassification(cls, mask=None):
        print(magentaStr("\n==> Running a PCA classification of the subtomograms:"))
        argDict = {
            'inSubtomos': cls.subtomosExtracted,
            'nClass': cls.pcaNumClasses
        }
        objLabel = 'PCA classif'
        if mask:
            argDict['mask'] = mask
            objLabel += ' with mask'

        protPcaClassif = cls.newProtocol(EmanProtPcaKMeansClassifySubtomos, **argDict)
        protPcaClassif.setObjLabel(objLabel)
        cls.launchProtocol(protPcaClassif)
        return protPcaClassif

    @staticmethod
    def getRepresentativeTestName(prot, classId, ext='.mrc'):
        return prot._getExtraPath(SPTCLS_00_DIR, 'threed_%02i%s' % (classId, ext))

    @staticmethod
    def getRepresentativeTestHalves(prot, classId):
        ext = '.mrc'
        pathAndBaseName = TestEmanTomoPcaClassificationStaClassic.getRepresentativeTestName(prot, classId, ext='')
        return [pathAndBaseName + '_even' + ext, pathAndBaseName + '_odd' + ext]

    def test_pcaClassifWithoutMask(self):
        pcaProt = self.runPcaClassification()
        self.checkPcaResults(pcaProt)

    def test_pcaClassifWithMask(self):
        pcaProt = self.runPcaClassification(mask=self.mask)
        self.checkPcaResults(pcaProt)

    def checkPcaResults(self, protPca):
        outSubtomos = getattr(protPca, pcaOutputObjects.subtomograms.name, None)
        outClasses = getattr(protPca, pcaOutputObjects.classes.name, None)
        outAverages = getattr(protPca, pcaOutputObjects.representatives.name, None)

        # CHECK SUBTOMO OUTPUT SET
        # Output set size must be lower or equal than the input set because some classes can have been purged
        testBozSize = (super().binnedBoxSize, super().binnedBoxSize, super().binnedBoxSize)
        self.assertLessEqual(outSubtomos.getSize(), super().nParticles)
        self.assertEqual(outSubtomos.getSamplingRate(), super().binnedSRate)
        self.assertEqual(outSubtomos.getDim(), testBozSize)
        # The subtomograms haven't been previously classified --> Each must have a classId in range(1, nClasses + 1)
        subtomoClassRange = range(1, self.pcaNumClasses + 1)
        for subtomo in outSubtomos:
            self.assertTrue(subtomo.getClassId() in subtomoClassRange)
            self.assertEqual(subtomo.getSamplingRate(), super().binnedSRate)
            self.assertEqual(subtomo.getDim(), testBozSize)

        # CHECK CLASSES OUTPUT SET
        self.assertSetSize(outClasses, self.pcaNumClasses)
        for class3d in outClasses:
            representative = class3d.getRepresentative()
            classId = class3d.getObjId()
            self.assertEqual(class3d.getSamplingRate(), super().binnedSRate)
            self.assertTrue(exists(representative.getFileName()))
            # The object id of each class corresponds to the class id number
            self.assertEqual(representative.getFileName(), self.getRepresentativeTestName(protPca, classId))
            self.assertTrue(representative.getHalfMaps(), self.getRepresentativeTestHalves(protPca, classId))
            for subtomo in class3d:
                self.assertEqual(subtomo.getClassId(), classId)

        # CHECK AVERAGES OUTPUT SET
        self.assertSetSize(outAverages, self.pcaNumClasses)
        for avg in outAverages:
            self.assertEqual(avg.getSamplingRate(), super().binnedSRate)
            # The object id of each class corresponds to the class id number
            classId = avg.getClassId()
            self.assertEqual(classId, avg.getObjId())
            self.assertEqual(avg.getFileName(), self.getRepresentativeTestName(protPca, classId))
            self.assertTrue(avg.getHalfMaps(), self.getRepresentativeTestHalves(protPca, classId))


class TestEmanTomoSubtomogramRefinementStaClassic(TestEmantomoStaClassicBase):

    mask = None
    avgSubtomo = None

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.runPreviousProtocols()

    @classmethod
    def runPreviousProtocols(cls):
        try:
            cls.mask = super().runCreate3dMask()  # Generate a mask
            super().runPreviousProtocols()
            cls.avgSubtomo = super().runAverageSubtomograms()
        except Exception as e:
            raise Exception('Some of the previous protocols failed --> \n%s' % e)

    @classmethod
    def runSubtomogramRefinement(cls, inputRef, mask=None):
        print(magentaStr("\n==> Refining the subtomograms:"))
        inputDict = {'inputSetOfSubTomogram': cls.subtomosExtracted,
                     'inputRef': inputRef,
                     'pkeep': 1,
                     'niter': 2,
                     'numberOfThreads': 10}

        objLabel = 'Subtomo refinement'
        if mask:
            inputDict['maskFile'] = mask
            objLabel += ' with mask'

        protTomoRefinement = cls.newProtocol(EmanProtTomoRefinement, **inputDict)
        protTomoRefinement.setObjLabel(objLabel)
        cls.launchProtocol(protTomoRefinement)
        return protTomoRefinement

    def test_subtomoRefinement(self):
        protSubtomoRefinement = self.runSubtomogramRefinement(self.avgSubtomo)
        self.checkRefinementResults(protSubtomoRefinement)

    def test_subTomoRefinementWithMask(self):
        protSubtomoRefinement = self.runSubtomogramRefinement(self.avgSubtomo, mask=self.mask)
        self.checkRefinementResults(protSubtomoRefinement)

    def checkRefinementResults(self, protRefineSubtomos):
        refinedSubtomos = getattr(protRefineSubtomos, EmanTomoRefinementOutputs.subtomograms.name, None)
        avgSubtomo = getattr(protRefineSubtomos, EmanTomoRefinementOutputs.subtomogramAverage.name, None)
        testDims = (super().binnedBoxSize, super().binnedBoxSize, super().binnedBoxSize)

        # Generation checking
        self.assertIsNotNone(refinedSubtomos)
        self.assertIsNotNone(avgSubtomo)

        # Avg checking
        self.checkAverage(avgSubtomo, boxSize=super().binnedBoxSize)

        # Subtomos checking
        self.assertEqual(refinedSubtomos.getDimensions(), testDims)
        self.assertSetSize(refinedSubtomos, self.nParticles, msg='Expected size of the generated subtomograms is '
                                                                 'different than expected: %i != %i' %
                                                                 (refinedSubtomos.getSize(), self.nParticles))
        self.assertEqual(refinedSubtomos.getCoordinates3D().getSize(), self.nParticles)
        for subTomogram in refinedSubtomos:
            self.assertEqual(subTomogram.getSamplingRate(), super().binnedSRate)
            self.assertTrue(hasattr(subTomogram, EMAN_COVERAGE))
            self.assertTrue(hasattr(subTomogram, EMAN_SCORE))
            matrix = subTomogram.getTransform(convention=TR_EMAN).getMatrix()
            self.assertEqual(matrix.shape, (4, 4))
            self.assertFalse(np.array_equal(matrix, np.eye(4)))  # Then it contains the angles and shitfs

        # FSCs checking
        fscs = getattr(protRefineSubtomos, EmanTomoRefinementOutputs.FSCs.name)
        self.assertSetSize(fscs, 3, msg="FSCs not registered properly")




